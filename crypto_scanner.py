# -*- coding: utf-8 -*-
"""Crypto_scanner.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ygRX9TNq7AmPLtrhaCtbdJTjf_37a9q8
"""

from google.colab import drive
drive.mount("/content/Crypto/", force_remount=True)

pip freeze > requirements.txt



import ccxt
import pandas as pd
import numpy as np
from time import sleep
import time
import seaborn as sns
import flask
import time
from time import struct_time
import tweepy
from math import pi
from bokeh.plotting import figure
from bokeh.io import output_notebook, show
from bokeh.resources import INLINE
from bokeh.models import LinearAxis, Range1d,HBar
from bokeh.models import ColumnDataSource, Label, LabelSet, Range1d
output_notebook(resources=INLINE)
from bokeh.plotting import figure, output_file, show

valid_check(ex,symbol)
pairs_check(ex,quote='USDT')
calculate_price(df_bid,df_ask,quote)
scanner(exchanges=['binance'],step_percentage=1,quote='USDT')

def pairs_check(ex,quote='USDT'):
    
    df_pairs = pd.DataFrame(getattr(ex, 'fetchMarkets')())
    df=df_pairs[df_pairs.quote==quote]
    return df.symbol

def calculate_price(df_bid,df_ask,quote):
    if(quote=='USDT'):
            df_bid['amount_USDT']=df_bid['amount']*df_bid['bid']
            df_ask['amount_USDT']=df_ask['amount']*df_ask['ask']
            df_bid['amount_BTC']=df_bid['amount_USDT']/btc_usdt
            df_ask['amount_BTC']=df_ask['amount_USDT']/btc_usdt
    elif(quote=='BTC'):
            df_bid['amount_BTC']=df_bid['amount']*df_bid['bid']
            df_ask['amount_BTC']=df_ask['amount']*df_ask['ask']
            df_bid['amount_USDT']=df_bid['amount_BTC']/btc_usdt
            df_ask['amount_USDT']=df_ask['amount_BTC']/btc_usdt
    return df_bid,df_ask
def valid_check(ex,symbol):
  try:
    if ex.has['fetchTicker']==True:
      flag=1
    else:
      flag=0
    
    ex.fetch_ticker(symbol)
    orderbook = getattr(ex, 'fetchL2OrderBook')(symbol,10000)
    
    return flag
  except:
    flag=0
    return flag

def scanner(exchanges=['binance'],step_percentage=1,quote='USDT'):
  start = time.time()
  df_ask_ex=pd.DataFrame()
  df_bid_ex=pd.DataFrame()
  #,'bitfinex','bitpanda','bybit','kraken','poloniex','kucoin','huobipro','bittrex','coinbase','bithumb']
  binance = ccxt.binance ()
  markets = binance.load_markets ()
  btc_usdt=pd.DataFrame(binance.fetch_ticker('BTC/USDT')).close[0]
      #bot.send_message(cid,btc_usdt
  print('BTC price is :',btc_usdt)
  flag=0
  for exchange in exchanges:
    
    
    id=exchange
    ex=eval ('ccxt.%s ()' % id)
    
    symbols=pairs_check(ex,quote)  
    if len(symbols)>0:
      symbol=symbols[symbols.index==symbols.index[-1]].values[0]
      flag=valid_check(ex,symbol)
    if flag==1:
      for symbol in symbols:
          flag=valid_check(ex,symbol)
          if(flag==1):
            try:
              orderbook = getattr(ex, 'fetchL2OrderBook')(symbol,10000)
              a=pd.DataFrame(ex.fetch_ticker(symbol))
              price=a[a.symbol==symbol].close[0]
              df_ask=pd.DataFrame(orderbook['asks'],columns=['ask','amount'])           
              df_bid=pd.DataFrame(orderbook['bids'],columns=['bid','amount'])
              
              if len(df_bid) !=0:
                  
                  df_bid,df_ask=calculate_price(df_bid,df_ask,quote)
                  maxs=df_bid["bid"].max()
                  mins=df_bid["bid"].min()
                  if(maxs>price*2):
                        maxs=price*2
                  if(mins<price/2):
                        mins=price/2
                  step=mins*step_percentage/100
                  df_bid=df_bid.groupby(pd.cut(df_bid["bid"], np.arange(mins, maxs+step, step))).agg({'amount':'sum','bid':'mean','amount_BTC':sum,'amount_USDT':sum})
                  df_bid['price']=df_bid.index
                  
                  mins=df_ask["ask"].min()
                  maxs=df_ask["ask"].max()
                  if(maxs>price*2):
                      maxs=price*2
                  if(mins<price/2):
                      mins=price/2
                  step=mins*step_percentage/100
                  df_ask=df_ask.groupby(pd.cut(df_ask["ask"], np.arange(mins, maxs+step, step))).agg({'amount':'sum','ask':'mean','amount_BTC':sum,'amount_USDT':sum})
                  df_ask['price']=df_ask.index
                  
                  df_ask['exchange']=id
                  df_ask['symbol']=symbol
                  df_bid['exchange']=id
                  df_bid['symbol']=symbol
                  df_bid,df_ask=calculate_price(df_bid,df_ask,quote)
                  df_ask_ex=pd.concat([df_ask,df_ask_ex],ignore_index=True)
                  df_bid_ex=pd.concat([df_bid,df_bid_ex],ignore_index=True)
                  
            except:
                
                continue       
      else:
          continue

  end = time.time()  
  elapsed = end - start
  print(elapsed)
  return df_bid_ex,df_ask_ex

df_bid_ex,df_ask_ex=scanner()

df_bid_ex

a=df_ask_ex[df_ask_ex['symbol']=='BTC/USDT']

a=a.sort_values(by=['ask'])
b=df_bid_ex[df_bid_ex['symbol']=='BTC/USDT']

b=b.sort_values(by=['bid'])

###a=a[a.price_high<60000]
#b=b[b.price_high>45000]
#a.sort_values(a.price.apply(lambda x : x.right),inplace=True)
sns.set(rc={'figure.figsize':(130,138.27)})
a=a[a.exchange=='binance']
b=b[b.exchange=='binance']
g=sns.catplot(x="price", y="amount_BTC",kind="bar",hue='exchange', data=a)
for ax in g.axes.flat:
    for label in ax.get_yticklabels():
        label.set_rotation(0)
    for label in ax.get_xticklabels():
        label.set_rotation(90)
h=sns.catplot(x="price", y="amount_BTC",kind="bar",hue='exchange', data=b)
for ax in h.axes.flat:
    for label in ax.get_yticklabels():
        label.set_rotation(0)
    for label in ax.get_xticklabels():
        label.set_rotation(90)
g.fig.set_size_inches(10,5)
h.fig.set_size_inches(10,5)

print(b.max())
print(a.max())

def comp_prev(a,shift=1):
    
    return (a.Close-a.Close.shift(shift))*100/a.Close

#OHLCV[(OHLCV.change<-5)]

time_tuple = (2021, 3, 10, 00, 00, 00, 0, 00, 0)
def OHLCV_extract(time_tuple):

  time_obj = struct_time(time_tuple)
  starttime=time.mktime(time_obj)*1000

  exchange=ccxt.binance()
  exchange.load_markets()
  OHLCV=pd.DataFrame()
  if exchange.has['fetchOHLCV']:
      start = time.time()

      exchanges=exchange.markets
      symbols=pairs_check(exchange,quote='USDT')
      symbols=['BTC/USDT']
      len(symbols)
      for symbol in symbols:
          time.sleep (exchange.rateLimit / 1000) # time.sleep wants seconds
          a=pd.DataFrame(exchange.fetch_ohlcv (symbol, '1h',since =int(starttime),limit=10000),columns=['Time','Open','High','Low','Close','Volume'])
          a['Date']=pd.to_datetime(a['Time']*1000000)
          a['symbol']=symbol
          a['change']=comp_prev(a)
          OHLCV=pd.concat([a,OHLCV],ignore_index=True)
      end=time.time()
      print(exchange,'-',end-start)
      return OHLCV

OHLCV=OHLCV_extract(time_tuple)



#OHLCV[(OHLCV.Date<-5)].sort_values('change')
OHLCV[(OHLCV.change<-5)].sort_values('change')

OHLCV['Change']=OHLCV.apply(lambda x : x.close[i])



#orders executed

import time
exchange=ccxt.binance()
exchange.load_markets()
symbol='BTC/USDT'
if exchange.has['fetchTrades']:
   # for symbol in exchange.markets:  # ensure you have called loadMarkets() or load_markets() method.
    d=pd.DataFrame(exchange.fetch_trades (symbol,since=exchange.fetchTime(params = {})-360000))

d

exchange.fetchTime(params = {})-3600



def tweettodf(text,time):

  a=re.split(" ",text)
  index=0
  for i, j in enumerate(a):

    try:
      tmp = int(j.replace(',',''))
      #print('The variable a number')
      index=i
    except:
      tmp=0
  a=a[index:]
 
  a[-1]=re.split("\n",a[-1])
  if len(a)>5:
    if ((a[1][0]=='#') & (a[4]=='transferred')):

      coin_count=a[0]
      symbol=a[1]
      amount_USD=a[2][1:]
      source=a[6]
      destination=a[-1][0]
      b=[time,coin_count,symbol,amount_USD,source,destination]
      return b
    else:
      return 0
  else:
    return 0

import tweepy
import re
consumer_key='TM6AVxSu9Dt8VuzcFzbyF0MwB'
consumer_secret='xUiJv2BxR8Aoax0qnd2ZT0fAgWBh35OfWZZ0Fnh5oMUys7NtWz'
#'AAAAAAAAAAAAAAAAAAAAAEkgOAEAAAAAxPy0xM9uwViASjj5XvEfAuHp1m8%3DOGdajLXAze3Oq7rez1iUlYVyiX1rXQUJOEeIF6CTR4ZACrCG6g''
auth = tweepy.OAuthHandler(consumer_key, consumer_secret)
auth.set_access_token('888817259342422016-wLATf1oBQ2BvlCES9T5slOatrJT1osy', 'smQOf65WtkMJohVr3TgdsR251TqAfgY4echPm082zFONW')

api = tweepy.API(auth, wait_on_rate_limit=True)
pattern='^#....('
#p = re.compile(r'*#....(*')
df_tweet=pd.DataFrame()
public_tweets = api.home_timeline()
public_tweets=api.user_timeline('@Whale_Alert',count =9000)
data=[]

userID='Whale_Alert'
all_tweets = []
tweets=api.user_timeline(screen_name=userID, 
                           # 200 is the maximum allowed count
                           count=300,
                           include_rts = False,
                  
                           # Necessary to keep full_text 
                           # otherwise only the first 140 words are extracted
                           tweet_mode = 'extended'
                           )
all_tweets.extend(tweets)
oldest_id = tweets[-1].id
while True:
    tweets = api.user_timeline(screen_name=userID, 
                           # 200 is the maximum allowed count
                           count=300,
                           include_rts = False,
                           max_id = oldest_id - 1,
                           # Necessary to keep full_text 
                           # otherwise only the first 140 words are extracted
                           tweet_mode = 'extended'
                           )
    if len(tweets) == 0:
        break
    oldest_id = tweets[-1].id
    all_tweets.extend(tweets)
    #print('N of tweets downloaded till now {}'.format(len(all_tweets)))

data=[]
for tweet in all_tweets:
    #print(tweet.full_text)
    text=tweet.full_text
    time=tweet.created_at
    temp=tweettodf(text,time)
    if temp !=0:
      data.append(tweettodf(text,time))
for tweet in public_tweets:
    #print(tweet.text)
    text=tweet.text
    time=tweet.created_at
    temp=tweettodf(text,time)
    if temp !=0:
      data.append(tweettodf(text,time))

df_tweet=pd.DataFrame(data,columns=['time','coin_count','coin','amount_USD','source','destination'])



df_tweet.drop_duplicates(inplace=True)

df_tweet.sort_values('time',ascending=False).head(20)

df_tweet.coin_count=df_tweet.coin_count.apply(lambda x : x.replace(',','')).astype(int)
df_tweet.amount_USD=df_tweet.amount_USD.apply(lambda x : x.replace(',','')).astype(int)
df_tweet.sort_values('amount_USD',ascending=False)

a=df_tweet[df_tweet.coin=='#BTC']
a=a.groupby([pd.Grouper(key='time', freq='1h'),'destination','source']).sum()
a.reset_index(inplace=True)
ex_list=['#Binance','#Coinbase','#Bitstamp','#OKEx','#Huobi', '#Kucoin', 'Huobi', '#Bitfinex']
a['coin_price']=a.amount_USD/a.coin_count
outfrom=a[a['source'].isin(ex_list)]
into=a[a['destination'].isin(ex_list)]
into.set_index('time',inplace=True)
outfrom.set_index('time',inplace=True)

df=OHLCV[OHLCV.symbol=='BTC/USDT']
df=df.set_index('Time')

z=pd.merge(df, a, how='left',on=['Date'])
z.set_index('Date',inplace=True)

df.drop(['Date','symbol','change'],axis=1,inplace=True)

df.index=pd.to_datetime(df.index*1000000)

df.resample('4h').mean()

df

output_file("label.html", title="label.py example")

df_ = df.copy()

inc = df_.Close > df_.Open
dec = df_.Open > df_.Close
#up=z.coin_price>z.Close
#down=z.coin_price<z.Close

w = 12*60*60*100
p = figure(x_axis_type="datetime", plot_width=1000, plot_height=800, title = "bitcoin price")

p.segment(df_.index, df_.High, df_.index, df_.Low, color="black")
p.vbar(df_.index[inc], w, df_.Open[inc], df_.Close[inc], fill_color="green", line_color="red")
p.vbar(df_.index[dec], w, df_.Open[dec], df_.Close[dec], fill_color="red", line_color="green")
#p.y_range = Range1d(df.Close.min(), df.Close.max()+10000)
#p.extra_y_ranges = {"NumStations": Range1d(start=0, end=a.coin_count.max()+10000)}
#p.add_layout(LinearAxis(y_range_name="NumStations"), 'right')
#y_range_name='NumStations'
average_in=into.coin_count.mean()
average_out=outfrom.coin_count.mean()
p.triangle(outfrom.index, outfrom.coin_price,name="mycircle",angle =3.14,fill_alpha=0.5,color='green',size=5*outfrom.coin_count/average_out)
p.triangle(into.index, into.coin_price,name="mycircle",fill_alpha=0.5 ,color='red',size=5*into.coin_count/average_in)

show(p)

ask=df_ask_ex[df_ask_ex.symbol=='BTC/USDT']
ask.ask=ask.ask.astype(int)